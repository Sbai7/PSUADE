// ************************************************************************
// Copyright (c) 2007   Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory.
// Written by the PSUADE team.
// All rights reserved.
//
// Please see the COPYRIGHT_and_LICENSE file for the copyright notice,
// disclaimer, contact information and the GNU Lesser General Public License.
//
// PSUADE is free software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License (as published by the Free Software
// Foundation) version 2.1 dated February 1999.
//
// PSUADE is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the terms and conditions of the GNU General
// Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// ************************************************************************
// Functions for the class UserRegression
// AUTHOR : CHARLES TONG
// DATE   : 2010
// ************************************************************************
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include "Psuade.h"
#include "UserRegression.h"
#include "sysdef.h"
#include "PsuadeUtil.h"
#include "PDFManager.h"
#include "PrintingTS.h"

#define PABS(x) (((x) > 0.0) ? (x) : -(x))

extern "C" {
   void dgels_(char *, int *, int *, int *, double *, int *,
               double *, int *, double *, int *, int *);
   void dgesvd_(char *, char *, int *, int *, double *, int *, double *,
               double *, int *, double *, int *, double *, int *, int *);
   void dgetrf_(int *, int *, double *, int *, int *, int *);
   void dgetri_(int *, double *, int *, int *, double*, int *, int *);
}

// ************************************************************************
// Constructor 
// ------------------------------------------------------------------------
UserRegression::UserRegression(int nInputs,int nSamples):
                               FuncApprox(nInputs,nSamples)
{
   int  ii;
   char response[501], inLine[501], pString[501];
   FILE *fp;

   // display banner and additonal information
   printAsterisks(PL_INFO, 0);
   printf("*                User Regression Analysis\n");
   printf("* R-square gives a measure of the goodness of the model.\n");
   printf("* R-square should be close to 1 if it is a good model.\n");
   printf("* Turn on rs_expert mode to select input scaling.\n");
   printf("* Option to use a ps_user_regr_info file to feed information\n");
   printf("* Turn on rs_expert mode to skip regression analysis.\n");
   printf("* Create ps_user_regr_info file to set information.\n");
   printEquals(PL_INFO, 0);

   faID_ = PSUADE_RS_REGRU;
   numArgs_ = 2;
   strcpy(auxArg_, "");
   strcpy(regFile_, "");
   fp = fopen("ps_user_regr_info", "r");
   if (fp == NULL)
   {
      printf("UserRegression: this regression method needs 3 pieces of\n");
      printf("                 information from you:\n");
      printf("  (1) number of basis functions in your regression (M).\n");
      printf("  (2) a user-generated executable file which evaluates\n");
      printf("      the basis functions given any set of sample points.\n");
      printf("      This file (say user.py) will be called via:\n\n");
      printf("          user.py paramfile outputfile \n\n");
      printf("       where param_file (generated by PSUADE) has the format: \n");
      printf("       line 1: <N sample points> <number of inputs m>\n");
      printf("       line 2: 1 followed by input values for sample point 1\n");
      printf("       line 3: 2 followed by input values for sample point 2\n");
      printf("       .....\n");
      printf("       Outputfile (created by user.py) should have this format: \n");
      printf("       line 1: 1 <M basis functions evaluated for sample 1> \n");
      printf("       line 2: 2 <M basis functions evaluated for sample 2> \n");
      printf("       .....\n");
      printf("  (3) auxiliary argument (e.g. selection for multi-output)\n");
      printf("      PSUADE will call the user executable via: \n");
      printf("           <executable> <inputfile> <outputfile> <aux arg>\n"); 
      sprintf(pString, "Enter number of basis function : ");
      numTerms_ = getInt(1,10000,pString);
      sprintf(pString, "Enter name of user-generated executable file : ");
      getString(pString, regFile_);
      ii = strlen(regFile_);
      regFile_[ii-1] = '\0';
      sprintf(pString, "Any auxiliary argument? (y or n) ");
      getString(pString, response);
      if (response[0] == 'y') 
      {
         sprintf(pString, "Enter argument (in one contiguous string) : ");
         getString(pString, auxArg_);
         numArgs_++;
      }
   }
   else
   {
      printf("UserRegression information file - ps_user_regr_info found.\n");
      fscanf(fp, "%d", &numTerms_);
      if (numTerms_ <= 0)
      {
         printf("UserRegression ERROR: numTerms should be > 0.\n");
         exit(1);
      }
      printf("UserRegression number of basis function = %d\n",numTerms_);
      fscanf(fp, "%s", regFile_);
      if (fscanf(fp, "%s", auxArg_) == EOF) strcpy(auxArg_, "");;
      fclose(fp);
      printf("UserRegression user-generated executable file = %s\n",regFile_);
   }
   fp = fopen(regFile_, "r");
   if (fp == NULL)
   {
      printf("UserRegression ERROR: user-generated executable %s not found.\n",
             regFile_);
      exit(1);
   }
   fclose(fp);
 
   noAnalysis_ = 0;
   if (numTerms_ == 1 && psRSExpertMode_ == 1)
   {
      printf("UserRegression: Since number of terms = 1, regression\n");
      printf("    analysis to estimate the basis function coefficients\n");
      printf("    may not be needed. Should we go ahead with regression\n");
      printf("    analysis (least-squares) to compute coefficients? (y or n) ");
      scanf("%s", response);
      fgets(inLine, 500, stdin);
      if (response[0] != 'y') noAnalysis_ = 1;
   }

   XNShift_ = new double[nInputs_];
   XNScale_ = new double[nInputs_];
   XScales_ = new int[nInputs_];
   for (ii = 0; ii < nInputs_; ii++)
   {
      XNShift_[ii]  = 0.0; 
      XNScale_[ii] = 1.0; 
      XScales_[ii] = 0; 
   }
   if (noAnalysis_ == 0 && psRSExpertMode_ == 1)
   {
      printf("Perform input scaling ? (y or n) ");
      scanf("%s", response);
      fgets(inLine, 500, stdin);
      if (response[0] == 'y') 
      {
         printf("Select the type of scaling for each input.\n");
         printf("Available ones are: \n");
         printf("0. no scaling\n");
         printf("1. scale only (i.e. X' = X * scale)\n");
         printf("2. shift and scale (X' = (X - lower bound) * scale)\n");
         for (ii = 0; ii < nInputs_; ii++)
         {
            sprintf(pString,"Choose scaling type (0, 1 or 2) for input %d : ",
                    ii+1);
            XScales_[ii] = getInt(0,2,pString);
         }
      }
   }

   fp = fopen(regFile_, "r");
   if (fp == NULL)
   {
      printf("UserRegression ERROR: user executable file not found.\n");
      printf("  This file is to be used for evaluating the basis functions\n");
      printf("  given any set of sample points. This file (say user.py) \n");
      printf("  will be called via:\n\n");
      printf("        user.py paramfile outputfile \n\n");
      printf("  where param_file (generated by PSUADE) has the format: \n");
      printf("  line 1: <N sample points> <number of inputs m>\n");
      printf("  line 2: 1 followed by input values for sample point 1\n");
      printf("  line 3: 2 followed by input values for sample point 2\n");
      printf("  .....\n");
      printf("  Outputfile (created by user.py) should have this format: \n");
      printf("  line 1: calculated values for M basis functions of sample 1\n");
      printf("  line 2: calculated values for M basis functions of sample 2\n");
      printf("  .....\n");
      exit(1);
   }
   fclose(fp);
   struct stat sb;
   if (stat(regFile_, &sb) != 0 || !(sb.st_mode & S_IXUSR))
   {
      printf("UserRegression WARNING : User-generated executable file does\n");
      printf("                         not have execute permission.\n");
   }

   regCoeffs_ = NULL;
   regStdevs_ = NULL;
   fuzzyC_ = NULL;
   coefTerms_ = NULL;
}

// ************************************************************************
// destructor
// ------------------------------------------------------------------------
UserRegression::~UserRegression()
{
   int ii;
   if (regCoeffs_ != NULL) delete [] regCoeffs_;
   if (regStdevs_ != NULL) delete [] regStdevs_;
   if (fuzzyC_    != NULL)
   {
      for (ii = 0; ii < numTerms_; ii++)
         if (fuzzyC_[ii] != NULL) delete [] fuzzyC_[ii];
      delete [] fuzzyC_;
   }
   if (coefTerms_ != NULL)
   {
      for (ii = 0; ii < numTerms_; ii++)
         if (coefTerms_[ii] != NULL) delete [] coefTerms_[ii];
      delete [] coefTerms_;
   }
   if (XNShift_ != NULL) delete [] XNShift_;
   if (XNScale_ != NULL) delete [] XNScale_;
}

// ************************************************************************
// initialize
// ------------------------------------------------------------------------
int UserRegression::initialize(double *X, double *Y)
{
   int    ii, status;
   double lb, ub, hx;
 
   status = 0;
   if (lowerBounds_ == NULL || upperBounds_ == NULL) status = 1;
   if (status == 0)
   {
      for (ii = 0; ii < nInputs_; ii++)
         if (lowerBounds_[ii] >= upperBounds_[ii]) status = 1; 
   }
   if (status == 1)
   {
      printf("UserRegression::initialize ERROR - bounds have not been\n");
      printf("                initialized.\n");
      return 0;
   }
 
   if (fuzzyC_ != NULL)
   {
      for (ii = 0; ii < numTerms_; ii++)
         if (fuzzyC_[ii] != NULL) delete [] fuzzyC_[ii];
      delete [] fuzzyC_;
      fuzzyC_ = NULL;
   }
   if (coefTerms_ != NULL)
   {
      for (ii = 0; ii < numTerms_; ii++)
         if (coefTerms_[ii] != NULL) delete [] coefTerms_[ii];
      delete [] coefTerms_;
      coefTerms_ = NULL;
   }
   if (regCoeffs_ != NULL) delete [] regCoeffs_;
   if (regStdevs_ != NULL) delete [] regStdevs_;
   regCoeffs_ = NULL;
   regStdevs_ = NULL;

   if (noAnalysis_ != 0)
   {
      regCoeffs_ = new double[1];
      regCoeffs_[0] = 1.0;
   }
   else
   {
      for (ii = 0; ii < nInputs_; ii++)
      {
         lb = lowerBounds_[ii];
         ub = upperBounds_[ii];
         hx = 1.0 / (ub - lb);
         if (XScales_[ii] == 1)
         {
            XNShift_[ii]  = 0.0;
            if      (lb < 0 && ub <= 0) XNScale_[ii] = - 1.0 / lb;
            else if (lb >= 0 && ub > 0) XNScale_[ii] = 1.0 / ub;
            else
            {
               hx = - lb;
               if (ub > lb) hx = ub;
               XNScale_[ii] = 1.0 / hx;
            }
         }
         else if (XScales_[ii] == 2)
         {
            if (lb < 0 && ub <= 0)
            {
               XNShift_[ii]  = ub;
               XNScale_[ii] = hx;
            }
            else 
            {
               XNShift_[ii]  = lb;
               XNScale_[ii] = hx;
            }
         }
         lb = XNShift_[ii];
         hx = XNScale_[ii]; 
         printf("Input %3d : shift = %e, scale = %e\n", ii+1,lb,hx);
      }
      status = analyze(X, Y);
      if (status != 0)
      {
         printf("UserRegression::initialize - ERROR detected.\n");
         return -1;
      }
   }
   return 0;
}

// ************************************************************************
// Generate lattice data based on the input set
// ------------------------------------------------------------------------
int UserRegression::genNDGridData(double *X, double *Y, int *N2,
                                 double **X2, double **Y2)
{
   int totPts, ss;

   if (initialize(X,Y) != 0)
   {
      printf("UserRegression::genNDGridData - ERROR detected.\n");
      (*N2) = 0;
      return -1;
   }

   if ((*N2) == -999) return 0;

   genNDGrid(N2, X2);
   if ((*N2) <= 0) return 0;
   totPts = (*N2);

   (*Y2) = new double[totPts];
   for (ss = 0; ss < totPts; ss++)
      (*Y2)[ss] = evaluatePoint(&((*X2)[ss*nInputs_]));

   return 0;
}

// ************************************************************************
// Generate 1D mesh results (set all other inputs to nominal values)
// ------------------------------------------------------------------------
int UserRegression::gen1DGridData(double *X, double *Y, int ind1,
                                  double *settings, int *NN, 
                                  double **XX, double **YY)
{
   int    totPts, mm, nn;
   double HX, *Xloc;

   if (initialize(X, Y) != 0)
   {
      printf("UserRegression::gen1DGridData - ERROR detected.\n");
      (*NN) = 0;
      return -1;
   }

   totPts = nPtsPerDim_;
   HX = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 

   (*NN) = totPts;
   (*XX) = new double[totPts];
   (*YY) = new double[totPts];
   Xloc  = new double[totPts*nInputs_];
   for (mm = 0; mm < nPtsPerDim_; mm++) 
      for (nn = 0; nn < nInputs_; nn++) 
         Xloc[mm*nInputs_+nn] = settings[nn]; 
   for (mm = 0; mm < nPtsPerDim_; mm++) 
   {
      Xloc[mm*nInputs_+ind1] = HX * mm + lowerBounds_[ind1];
      (*XX)[mm] = Xloc[mm*nInputs_+ind1];
   }
   evaluatePoint(totPts,Xloc,*YY);

   delete [] Xloc;
   return 0;
}

// ************************************************************************
// Generate 2D mesh results (set all other inputs to nominal values)
// ------------------------------------------------------------------------
int UserRegression::gen2DGridData(double *X, double *Y, int ind1,
                        int ind2, double *settings, int *NN, 
                        double **XX, double **YY)
{
   int    totPts, mm, nn, kk, index;
   double *HX, *Xloc;

   if (initialize(X, Y) != 0)
   {
      printf("UserRegression::gen2DGridData - ERROR detected.\n");
      (*NN) = 0;
      return -1;
   }

   totPts = nPtsPerDim_ * nPtsPerDim_;
   HX    = new double[2];
   HX[0] = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 
   HX[1] = (upperBounds_[ind2] - lowerBounds_[ind2]) / (nPtsPerDim_ - 1); 

   (*NN) = totPts;
   (*XX) = new double[totPts * 2];
   (*YY) = new double[totPts];
   Xloc  = new double[totPts*nInputs_];
   for (mm = 0; mm < nPtsPerDim_; mm++) 
   {
      for (nn = 0; nn < nPtsPerDim_; nn++) 
      {
         index = mm * nPtsPerDim_ + nn;
         for (kk = 0; kk < nInputs_; kk++) 
            Xloc[index*nInputs_+kk] = settings[kk]; 
      }
   }
   for (mm = 0; mm < nPtsPerDim_; mm++) 
   {
      for (nn = 0; nn < nPtsPerDim_; nn++)
      {
         index = mm * nPtsPerDim_ + nn;
         Xloc[index*nInputs_+ind1] = HX[0] * mm + lowerBounds_[ind1];
         Xloc[index*nInputs_+ind2] = HX[1] * nn + lowerBounds_[ind2];
         (*XX)[index*2]   = Xloc[index*nInputs_+ind1];
         (*XX)[index*2+1] = Xloc[index*nInputs_+ind2];
      }
   }
   evaluatePoint(totPts,Xloc,*YY);

   delete [] Xloc;
   delete [] HX;
   return 0;
}

// ************************************************************************
// Generate 3D mesh results (setting others to some nominal values) 
// ------------------------------------------------------------------------
int UserRegression::gen3DGridData(double *X, double *Y, int ind1,
                                  int ind2, int ind3, double *settings, 
                                  int *NN, double **XX, double **YY)
{
   int    totPts, mm, nn, pp, kk, index;
   double *HX, *Xloc;

   if (initialize(X, Y) != 0)
   {
      printf("UserRegression::gen3DGridData - ERROR detected.\n");
      (*NN) = 0;
      return -1;
   }

   totPts = nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_;
   HX    = new double[3];
   HX[0] = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 
   HX[1] = (upperBounds_[ind2] - lowerBounds_[ind2]) / (nPtsPerDim_ - 1); 
   HX[2] = (upperBounds_[ind3] - lowerBounds_[ind3]) / (nPtsPerDim_ - 1); 

   (*NN) = totPts;
   (*XX) = new double[totPts * 3];
   (*YY) = new double[totPts];
   Xloc  = new double[totPts*nInputs_];
   for (mm = 0; mm < nPtsPerDim_; mm++) 
   {
      for (nn = 0; nn < nPtsPerDim_; nn++)
      {
         for (pp = 0; pp < nPtsPerDim_; pp++)
         {
            index = mm * nPtsPerDim_ * nPtsPerDim_ + nn * nPtsPerDim_ + pp;
            for (kk = 0; kk < nInputs_; kk++)
               Xloc[index*nInputs_+kk] = settings[kk];
         }
      }
   }
   for (mm = 0; mm < nPtsPerDim_; mm++) 
   {
      for (nn = 0; nn < nPtsPerDim_; nn++)
      {
         for (pp = 0; pp < nPtsPerDim_; pp++)
         {
            index = mm * nPtsPerDim_ * nPtsPerDim_ + nn * nPtsPerDim_ + pp;
            Xloc[index*nInputs_+ind1] = HX[0] * mm + lowerBounds_[ind1];
            Xloc[index*nInputs_+ind2] = HX[1] * nn + lowerBounds_[ind2];
            Xloc[index*nInputs_+ind3] = HX[2] * pp + lowerBounds_[ind3];
            (*XX)[index*3]   = Xloc[index*nInputs_+ind1];
            (*XX)[index*3+1] = Xloc[index*nInputs_+ind2];
            (*XX)[index*3+2] = Xloc[index*nInputs_+ind3];
         }
      }
   }
   evaluatePoint(totPts,Xloc,*YY);

   delete [] Xloc;
   delete [] HX;
   return 0;
}

// ************************************************************************
// Generate 4D mesh results (setting others to some nominal values) 
// ------------------------------------------------------------------------
int UserRegression::gen4DGridData(double *X, double *Y, int ind1, int ind2,
                                  int ind3, int ind4, double *settings, 
                                  int *NN, double **XX, double **YY)
{
   int    totPts, mm, nn, pp, qq, index;
   double *HX, *Xloc;

   if (initialize(X, Y) != 0)
   {
      printf("UserRegression::gen4DGridData - ERROR detected.\n");
      (*NN) = 0;
      return -1;
   }

   totPts = nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_;
   HX    = new double[4];
   HX[0] = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 
   HX[1] = (upperBounds_[ind2] - lowerBounds_[ind2]) / (nPtsPerDim_ - 1); 
   HX[2] = (upperBounds_[ind3] - lowerBounds_[ind3]) / (nPtsPerDim_ - 1); 
   HX[3] = (upperBounds_[ind4] - lowerBounds_[ind4]) / (nPtsPerDim_ - 1); 

   (*NN) = totPts;
   (*XX) = new double[totPts * 4];
   (*YY) = new double[totPts];
   Xloc  = new double[nInputs_];
   for (nn = 0; nn < nInputs_; nn++) Xloc[nn] = settings[nn]; 
    
   for (mm = 0; mm < nPtsPerDim_; mm++) 
   {
      for (nn = 0; nn < nPtsPerDim_; nn++)
      {
         for (pp = 0; pp < nPtsPerDim_; pp++)
         {
            for (qq = 0; qq < nPtsPerDim_; qq++)
            {
               index = mm*nPtsPerDim_*nPtsPerDim_*nPtsPerDim_ +
                       nn*nPtsPerDim_*nPtsPerDim_ + pp * nPtsPerDim_ + qq;
               Xloc[ind1] = HX[0] * mm + lowerBounds_[ind1];
               Xloc[ind2] = HX[1] * nn + lowerBounds_[ind2];
               Xloc[ind3] = HX[2] * pp + lowerBounds_[ind3];
               Xloc[ind4] = HX[3] * qq + lowerBounds_[ind4];
               (*XX)[index*4]   = Xloc[ind1];
               (*XX)[index*4+1] = Xloc[ind2];
               (*XX)[index*4+2] = Xloc[ind3];
               (*XX)[index*4+3] = Xloc[ind4];
               (*YY)[index] = evaluatePoint(Xloc);
            }
         }
      }
   }

   delete [] Xloc;
   delete [] HX;
   return 0;
}

// ************************************************************************
// Evaluate a given point
// ------------------------------------------------------------------------
double UserRegression::evaluatePoint(double *X)
{
   int    iOne=1;
   double Y;
   evaluatePoint(iOne, X, &Y);
   return Y;
}

// ************************************************************************
// Evaluate a number of points
// ------------------------------------------------------------------------
double UserRegression::evaluatePoint(int npts, double *X, double *Y)
{
   int    ii, ind, kk;
   double Yt, ddata;
   char   sysCmd[500], lineIn[5001];
   FILE   *fp;

   if (regCoeffs_ == NULL)
   {
      printf("UserRegression ERROR: need to call initialize first.\n");
      return 0.0;
   }

   fp = fopen("ps_input", "w");
   if (fp == NULL)
   {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
   }
   fprintf(fp, "%d %d\n", npts, nInputs_);
   for (kk = 0; kk < npts; kk++)
   {
      fprintf(fp, "%d", kk+1);
      for (ii = 0; ii < nInputs_; ii++)
      {
         ddata = (X[kk*nInputs_+ii] - XNShift_[ii]) * XNScale_[ii];
         fprintf(fp, " %24.16e", ddata);
      }
      fprintf(fp, "\n");
   }
   fprintf(fp, "\n");
   fclose(fp);
   if (outputLevel_ > 2) 
      printOutTS(PL_INFO,"Evaluating basis function with user regressor...\n");
   if (numArgs_ == 2) 
   {
      if (psPythonOverride_ == 0)
      {
         if (psPythonInterpreter_ != NULL)
         {
            sprintf(sysCmd,"%s %s ps_input ps_output",psPythonInterpreter_,
                    regFile_);
         }
         else sprintf(sysCmd,"python %s ps_input ps_output", regFile_);
      }
      else sprintf(sysCmd,"%s ps_input ps_output", regFile_);
   }
   else
   {
      if (psPythonOverride_ == 0)
      {
         if (psPythonInterpreter_ != NULL)
         {
            sprintf(sysCmd,"%s %s ps_input ps_output %s",psPythonInterpreter_,
                    regFile_,auxArg_);
         }
         else sprintf(sysCmd,"python %s ps_input ps_output %s",regFile_,auxArg_);
      }
      else sprintf(sysCmd,"%s ps_input ps_output %s", regFile_,auxArg_);
   }
   if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
   system(sysCmd);
   if (outputLevel_ > 2) 
      printOutTS(PL_INFO, "Basis function evaluation completed.\n");
 
   fp = fopen("ps_output", "r");
   if (fp == NULL)
   {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
   }
   for (kk = 0; kk < npts; kk++)
   {
      if (kk == 0)
      {
         fscanf(fp, "%s", lineIn); 
         if (lineIn[0] == '#')
         {
            fgets(lineIn, 5000, fp);
            fscanf(fp, "%d", &ind);
         }
         else sscanf(lineIn, "%d", &ind);
      }
      else fscanf(fp, "%d", &ind);
      if (ind != kk+1)
      {
         printf("ERROR: user output file does not have correct format.\n");
         printf("  Expected index = %d, actual index = %d\n",kk+1,ind);
         fclose(fp);
         exit(1);
      }
      Yt = 0.0;
      for (ii = 0; ii < numTerms_; ii++)
      {
         fscanf(fp, "%lg", &ddata);
         Yt += regCoeffs_[ii] * ddata;
      }
      if (fgets(lineIn, 5000, fp) == NULL && kk < npts-1)
      {
         printf("ERROR: user output file does not have enough data (%d).\n",
                kk);
         fclose(fp);
         exit(1);
      }
      Y[kk] = Yt;
   }
   fclose(fp);
   unlink("ps_input");
   unlink("ps_output");
   return 0.0;
}

// ************************************************************************
// Evaluate a given point and also its standard deviation
// ------------------------------------------------------------------------
double UserRegression::evaluatePointFuzzy(double *X, double &std)
{
   int    iOne=1;
   double Y, ddata;
   evaluatePointFuzzy(iOne, X, &Y, &ddata);
   std = ddata;
   return Y;
}

// ************************************************************************
// Evaluate a number of points and also their standard deviations
// ------------------------------------------------------------------------
double UserRegression::evaluatePointFuzzy(int npts, double *X, double *Y,
                                          double *Ystd)
{
   int    tt, kk, ii, ntimes=100;
   double *Ys, *Yt, mean, std, ddata;
   char   sysCmd[500], lineIn[5001];
   FILE   *fp;
 
   if (regCoeffs_ == NULL)
   {
      printf("UserRegression ERROR: initialize has not been called.\n");
      exit(1);
   }

   if (noAnalysis_ == 1 || fuzzyC_ == NULL)
   {
      evaluatePoint(npts, X, Y);
      for (kk = 0; kk < npts; kk++) Ystd[kk] = 0.0;
   }
   else
   {
      fp = fopen("ps_input", "w");
      if (fp == NULL)
      {
         printf("fopen returned NULL in file %s line %d, exiting\n",
                __FILE__, __LINE__);
         exit(1);
      }
      fprintf(fp, "%d %d\n", npts, nInputs_);
      for (kk = 0; kk < npts; kk++)
      {
         fprintf(fp, "%d", kk+1);
         for (ii = 0; ii < nInputs_; ii++)
         {
            ddata = (X[kk*nInputs_+ii] - XNShift_[ii]) * XNScale_[ii];
            fprintf(fp, " %24.16e", ddata);
         }
         fprintf(fp, "\n");
      }
      fprintf(fp, "\n");
      fclose(fp);
      if (numArgs_ == 2) 
      {
         if (psPythonOverride_ == 0)
         {
            if (psPythonInterpreter_ != NULL)
            {
               sprintf(sysCmd,"%s %s ps_input ps_output",psPythonInterpreter_,
                       regFile_);
            }
            else sprintf(sysCmd,"python %s ps_input ps_output",regFile_);
         }
         else sprintf(sysCmd,"%s ps_input ps_output", regFile_);
      }
      else
      {
         if (psPythonOverride_ == 0)
         {
            if (psPythonInterpreter_ != NULL)
            {
               sprintf(sysCmd,"%s %s ps_input ps_output %s",
                       psPythonInterpreter_,regFile_,auxArg_);
            }
            else 
               sprintf(sysCmd,"python %s ps_input ps_output %s",regFile_,
                       auxArg_);
         }
         else sprintf(sysCmd,"%s ps_input ps_output %s", regFile_,auxArg_);
      }
      if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
      system(sysCmd);
 
      fp = fopen("ps_output", "r");
      if (fp == NULL)
      {
         printf("fopen returned NULL in file %s line %d, exiting\n",
                __FILE__, __LINE__);
         exit(1);
      }
      Ys = new double[ntimes];
      Yt = new double[numTerms_];
      for (kk = 0; kk < npts; kk++)
      {
         if (kk == 0)
         {
            fscanf(fp, "%s", lineIn); 
            if (lineIn[0] == '#')
            {
               fgets(lineIn, 5000, fp);
               fscanf(fp, "%d", &ii);
            }
            else sscanf(lineIn, "%d", &ii);
         }
         else fscanf(fp, "%d", &ii);
         if (ii != kk+1)
         {
            printf("ERROR: user output file does not have correct format.\n");
            printf("  Expected index = %d, actual index = %d\n",kk+1,ii);
            fclose(fp);
            exit(1);
         }
         for (ii = 0; ii < numTerms_; ii++) fscanf(fp, "%lg", &Yt[ii]);
         if (fgets(lineIn, 5000, fp) == NULL && kk < npts-1)
         {
            printf("ERROR: user output file does not have enough data (%d).\n",
                   kk);
            fclose(fp);
            exit(1);
         }
         for (tt = 0; tt < ntimes; tt++)
         {
            Ys[tt] = 0.0;
            for (ii = 0; ii < numTerms_; ii++) 
               Ys[tt] += fuzzyC_[ii][tt] * Yt[ii];
         }
         mean = 0.0;
         for (tt = 0; tt < ntimes; tt++) mean += Ys[tt];
         mean /= (double) ntimes;
         std = 0.0;
         for (tt = 0; tt < ntimes; tt++) std += (Ys[tt]-mean)*(Ys[tt]-mean);
         std = sqrt(std/(ntimes-1));
         Y[kk] = mean;
         Ystd[kk] = std;
      }
      fclose(fp);
      unlink("ps_input");
      unlink("ps_output");
      delete [] Ys;
      delete [] Yt;
   }
   return 0.0;
}

// ************************************************************************
// perform mean/variance analysis
// ------------------------------------------------------------------------
int UserRegression::analyze(double *X, double *Y)
{
   int    N, M, mm, nn, wlen, info, NRevised;
   double *B, *XX, SSresid, SStotal, R2, *XTX, var, *Bvar;
   double esum, ymax, *WW, *SS, *AA, *UU, *VV;
   char   jobu  = 'S', jobvt = 'S';
   char   pString[100];
   FILE   *fp;

   if (nSamples_ <= numTerms_)
   {
      printf("UserRegression::analyze ERROR - sample size too small.\n");
      return -1;
   } 
   
   N = loadXMatrix(X, &XX);
   M = nSamples_;

   wlen = 5 * M;
   AA = new double[M*N];
   UU = new double[M*N];
   SS = new double[N];
   VV = new double[M*N];
   WW = new double[wlen];
   B  = new double[N];
   for (mm = 0; mm < M; mm++)
      for (nn = 0; nn < N; nn++)
         AA[mm+nn*M] = sqrt(weights_[mm]) * XX[mm+nn*M];

   if (psMasterMode_ == 1)
   {
      fp = fopen("user_regression_matrix.m", "w");
      if(fp == NULL)
      {
         printf("fopen returned NULL in file %s line %d, exiting\n",
                __FILE__, __LINE__);
         exit(1);
      }
      fprintf(fp, "%% the sample matrix where svd is computed\n");
      fprintf(fp, "%% the last column is the right hand side\n");
      fprintf(fp, "%% B is the vector of coefficients\n");
      fprintf(fp, "AA = [\n");
      for (mm = 0; mm < M; mm++)
      {
         for (nn = 0; nn < N; nn++)
            fprintf(fp, "%24.16e ", AA[mm+nn*M]);
         fprintf(fp, "%24.16e \n",Y[mm]);
      }
      fprintf(fp, "];\n");
      fprintf(fp, "A = AA(:,1:%d);\n", N);
      fprintf(fp, "Y = AA(:,%d);\n", N+1);
      fprintf(fp, "B = A \\ Y;\n");
      fclose(fp);
      printf("Regression matrix written to user_regression_matrix.m\n");
   }

   if (outputLevel_ > 3) printf("Running SVD ...\n");
   dgesvd_(&jobu, &jobvt, &M, &N, AA, &M, SS, UU, &M, VV, &N, WW,
           &wlen, &info);
   if (outputLevel_ > 3) 
      printf("SVD completed: status = %d (should be 0).\n",info);

   if (info != 0)
   {
      printf("* UserRegression Info: dgesvd returns a nonzero (%d).\n",info);
      printf("* UserRegression terminates further processing.\n");
      delete [] XX;
      delete [] AA;
      delete [] UU;
      delete [] SS;
      delete [] VV;
      delete [] WW;
      delete [] B;
      return -1;
   }

   mm = 0;
   for (nn = 0; nn < N; nn++) if (SS[nn] < 0) mm++;
   if (mm > 0)
   {
      printf("* UserRegression WARNING: some of the singular values\n");
      printf("*            are < 0. May spell trouble but will\n");
      printf("*            proceed anyway (%d).\n",mm);
   }
   if (SS[0] == 0.0) NRevised = 0;
   else
   {
      NRevised = N;
      for (nn = 1; nn < N; nn++)
         if (SS[nn-1] > 0 && SS[nn]/SS[nn-1] < 1.0e-8) NRevised--;
   }
   if (NRevised < N)
   {
      printf("* UserRegression ERROR: true rank of sample = %d (need %d)\n",
             NRevised, N);
      delete [] XX;
      delete [] AA;
      delete [] UU;
      delete [] SS;
      delete [] VV;
      delete [] WW;
      delete [] B;
      return -1;
   }
   if (psMasterMode_ == 1)
   {
      printf("UserRegression: matrix singular values \n");
      printf("The VERY small ones may cause poor numerical accuracy,\n");
      printf("but not keeping them may ruin the approximation power.\n");
      printf("So, select them judiciously.\n");
      for (nn = 0; nn < N; nn++)
         printf("Singular value %5d = %e\n", nn+1, SS[nn]);
      sprintf(pString, "How many to keep (1 - %d, 0 - all) ? ", N);
      NRevised = getInt(0,N,pString);
      if (NRevised == 0) NRevised = N;
      for (nn = NRevised; nn < N; nn++) SS[nn] = 0.0;
   }
   else
   {
      NRevised = N;
      for (nn = 1; nn < N; nn++)
      {
         if (SS[nn-1] > 0.0 && SS[nn]/SS[nn-1] < 1.0e-8)
         {
            SS[nn] = 0.0;
            NRevised--;
         }
      }
   }
   for (mm = 0; mm < NRevised; mm++)
   {
      WW[mm] = 0.0;
      for (nn = 0; nn < M; nn++)
         WW[mm] += UU[mm*M+nn] * sqrt(weights_[nn]) * Y[nn];
   }
   for (nn = 0; nn < NRevised; nn++) WW[nn] /= SS[nn];
   for (nn = NRevised; nn < N; nn++) WW[nn] = 0.0;
   for (mm = 0; mm < N; mm++)
   {
      B[mm] = 0.0;
      for (nn = 0; nn < NRevised; nn++) B[mm] += VV[mm*N+nn] * WW[nn];
   }
   delete [] AA;
   delete [] SS;
   delete [] UU;
   delete [] VV;

   if (psMasterMode_ == 1)
   {
      fp = fopen("user_regression_error.m", "w");
      if(fp == NULL)
      {
	 printf("fopen returned NULL in file %s line %d, exiting\n",
                __FILE__, __LINE__);
         exit(1);
      }
      fprintf(fp, "%% This file contains errors of each data point.\n");
   }
   else fp = NULL;

   esum = ymax = 0.0;
   for (mm = 0; mm < nSamples_; mm++)
   {
      WW[mm] = 0.0;
      for (nn = 0; nn < N; nn++)
         WW[mm] = WW[mm] + XX[mm+nn*nSamples_] * B[nn];
      WW[mm] = WW[mm] - Y[mm];
      esum = esum + WW[mm] * WW[mm] * weights_[mm];
      if (fp != NULL) 
         fprintf(fp, "%6d %24.16e\n",mm+1,WW[mm]*sqrt(weights_[mm]));
      if (PABS(Y[mm]) > ymax) ymax = PABS(Y[mm]);
   }
   esum /= (double) nSamples_;
   esum = sqrt(esum);
   printAsterisks(PL_INFO, 0);
   printf("*            User Regression Analysis Statistics\n");
   printEquals(PL_INFO, 0);
   printf("* UserRegression:: LS mean error = %11.4e (max=%11.4e)\n",
          esum, ymax); 

   if (fp != NULL)
   {
      fclose(fp);
      printf("FILE user_regression_error.m contains data errors.\n");
   }

   computeSS(N, XX, Y, B, SSresid, SStotal);
   if (SStotal == 0.0) R2 = 1.0;
   else                R2  = 1.0 - SSresid / SStotal;
   if (nSamples_ > N) var = SSresid / (double) (nSamples_ - N);
   else               var = 0.0;
   if (var < 0)
   { 
      if (PABS(var) > 1.0e-12)
           printf("Regression WARNING: var < 0.\n");
      else var = 0;
   }

   Bvar = new double[N];
   computeXTX(N, XX, &XTX);
   computeCoeffVariance(N, XTX, var, Bvar);
   regCoeffs_ = B;
   regStdevs_ = Bvar;

   PDFManager *pdfman = new PDFManager();
   int    cc, nTimes=100;
   int    *inPDFs = new int[numTerms_];
   double *inMeans = new double[numTerms_];
   double *inStds = new double[numTerms_];
   double *inUppers = new double[numTerms_];
   double *inLowers = new double[numTerms_];
   for (nn = 0; nn < numTerms_; nn++)
   {
      inPDFs[nn] = PSUADE_PDF_NORMAL;
      inMeans[nn] = regCoeffs_[nn];
      inStds[nn] = regStdevs_[nn];
      inUppers[nn] = inMeans[nn] + 4.0 * inStds[nn];
      inLowers[nn] = inMeans[nn] - 4.0 * inStds[nn];
      {
         if (inUppers[nn] > 0) inUppers[nn] *= (1.0 + 1.0e-14);
         else                  inUppers[nn] *= (1.0 - 1.0e-14);
         if (inLowers[nn] > 0) inLowers[nn] *= (1.0 - 1.0e-14);
         else                  inLowers[nn] *= (1.0 + 1.0e-14);
         if (inUppers[nn] == 0.0) inUppers[nn] = 1e-14;
         if (inLowers[nn] == 0.0) inLowers[nn] = -1e-14;
      }
   }
   pdfman->initialize(numTerms_,inPDFs,inMeans,inStds,covMatrix_,NULL,NULL);
   psVector vLower, vUpper, vOut;
   vLower.load(numTerms_, inLowers);
   vUpper.load(numTerms_, inUppers);
   vOut.setLength(numTerms_*nTimes);
   pdfman->genSample(nTimes, vOut, vLower, vUpper);
   fuzzyC_ = new double*[numTerms_];
   for (nn = 0; nn < numTerms_; nn++)
   {
      fuzzyC_[nn] = new double[nTimes];
      for (cc = 0; cc < nTimes; cc++)
         fuzzyC_[nn][cc] = vOut[cc*numTerms_+nn];
   }
   delete pdfman;
   delete [] inPDFs;
   delete [] inStds;
   delete [] inMeans;
   delete [] inLowers;
   delete [] inUppers;

   if (outputLevel_ >= 0)
   {
      printRC(N, B, Bvar, XX, Y);
      printf("* UserRegression model R-square = %12.4e\n", R2);
      printf("* adjusted   R-square = %12.4e\n",
             1.0 - (1.0 - R2) * ((M - 1) / (M - N - 1)));
      printEquals(PL_INFO, 0);
   }
   fp = NULL;
   if (psRSCodeGen_ == 1) fp = fopen("psuade_rs.info", "w");
   if (fp != NULL)
   {
      fprintf(fp,"/* *******************************************/\n");
      fprintf(fp,"/* User regression interpolator form PSUADE. */\n");
      fprintf(fp,"/* ==========================================*/\n");
      fprintf(fp,"/* This file contains information for interpolation\n");
      fprintf(fp,"   using response surface. Follow the steps below:\n");
      fprintf(fp,"   1. move this file to *.c file (e.g. main.c)\n");
      fprintf(fp,"   2. Modify the main.c program\n");
      fprintf(fp,"      a. replace func with your user-defined function\n");
      fprintf(fp,"   3. Compile main.c (cc -o main main.c -lm) \n");
      fprintf(fp,"   4. run: main input output\n");
      fprintf(fp,"          where input has the number of inputs and\n");
      fprintf(fp,"          the input values\n");
      fprintf(fp,"*/\n");
      fprintf(fp,"/* ==========================================*/\n");
      fprintf(fp,"#include <math.h>\n");
      fprintf(fp,"#include <stdlib.h>\n");
      fprintf(fp,"#include <stdio.h>\n");
      fprintf(fp,"int interpolate(int,double*,double*,double*);\n");
      fprintf(fp,"main(int argc, char **argv) {\n");
      fprintf(fp,"  int    i, iOne=1, nInps;\n");
      fprintf(fp,"  double X[%d], Y, S;\n",nInputs_);
      fprintf(fp,"  FILE   *fIn=NULL, *fOut=NULL;\n");
      fprintf(fp,"  if (argc != 3) {\n");
      fprintf(fp,"     printf(\"ERROR: not enough argument.\\n\");\n");
      fprintf(fp,"     exit(1);\n");
      fprintf(fp,"  }\n");
      fprintf(fp,"  fIn = fopen(argv[1], \"r\");\n");
      fprintf(fp,"  if (fIn == NULL) {\n");
      fprintf(fp,"     printf(\"ERROR: cannot open input file.\\n\");\n");
      fprintf(fp,"     exit(1);\n");
      fprintf(fp,"  }\n");
      fprintf(fp,"  fscanf(fIn, \"%%d\", &nInps);\n");
      fprintf(fp,"  if (nInps != %d) {\n", nInputs_);
      fprintf(fp,"    printf(\"ERROR - wrong nInputs.\\n\");\n");
      fprintf(fp,"    exit(1);\n");
      fprintf(fp,"  }\n");
      fprintf(fp,"  for (i=0; i<%d; i++) fscanf(fIn, \"%%lg\", &X[i]);\n",
              nInputs_);
      fprintf(fp,"  fclose(fIn);\n");
      fprintf(fp,"  interpolate(iOne, X, &Y, &S);\n");
      fprintf(fp,"  printf(\"Y = %%e\\n\", Y);\n");
      fprintf(fp,"  printf(\"S = %%e\\n\", S);\n");
      fprintf(fp,"  fOut = fopen(argv[2], \"w\");\n");
      fprintf(fp,"  if (fOut == NULL) {\n");
      fprintf(fp,"     printf(\"ERROR: cannot open output file.\\n\");\n");
      fprintf(fp,"     exit(1);\n");
      fprintf(fp,"  }\n");
      fprintf(fp,"  fprintf(fOut,\" %%e\\n\", Y);\n");
      fprintf(fp,"  fclose(fOut);\n");
      fprintf(fp,"}\n");
      fprintf(fp,"/* ==========================================*/\n");
      fprintf(fp,"/* Regression interpolation function         */\n");
      fprintf(fp,"/* X[0], X[1],   .. X[m-1]   - first point\n");
      fprintf(fp," * X[m], X[m+1], .. X[2*m-1] - second point\n");
      fprintf(fp," * ... */\n");
      fprintf(fp,"/* ==========================================*/\n");
      fprintf(fp,"static double\n");
      fprintf(fp,"Coefs[%d][2] = \n", N);
      fprintf(fp,"{\n");
      for (mm = 0; mm < numTerms_; mm++)
         fprintf(fp,"  { %24.16e , %24.16e},\n",B[mm],Bvar[mm]);
      fprintf(fp,"};\n");
      fprintf(fp,"void getCoefs(int kk, double *coefs);\n");
      fprintf(fp,"/* ==========================================*/\n");
      fprintf(fp,"int func(int nInps, double *X, double *Y);\n");
      fprintf(fp,"int interpolate(int npts,double *X,double *Y,double *S){\n");
      fprintf(fp,"  int    kk, ii, jj, nInps=%d, ntimes=100;\n",nInputs_);
      fprintf(fp,"  int    nterms=%d;\n",numTerms_);
      fprintf(fp,"  double y, *x, *u, *yt, *coefs, *yy, mean, std;\n");
      fprintf(fp,"  coefs = (double *) malloc(%d *sizeof(double));\n",
                 numTerms_);
      fprintf(fp,"  u = (double *) malloc(%d *sizeof(double));\n",numTerms_);
      fprintf(fp,"  yt = (double *) malloc(ntimes * sizeof(double));\n");
      fprintf(fp,"  for (ii = 0; ii < npts; ii++) {\n");
      fprintf(fp,"    x = &(X[ii * nInps]);\n");
      fprintf(fp,"    for (kk = 0; kk < ntimes; kk++) {\n");
      fprintf(fp,"      getCoefs(kk, coefs);\n");
      fprintf(fp,"      func(nInps,x,u);\n");
      fprintf(fp,"      y = 0.0;\n");
      fprintf(fp,"      for (jj = 0; jj < nterms; jj++)\n");
      fprintf(fp,"        y += coefs[jj] * u[jj];\n");
      fprintf(fp,"      yt[kk] = y * %e + %e;\n", YStd_, YMean_);
      fprintf(fp,"    }\n");
      fprintf(fp,"    mean = 0.0;\n");
      fprintf(fp,"    for (kk = 0; kk < ntimes; kk++) mean += yt[kk];\n");
      fprintf(fp,"    mean /= ntimes;\n");
      fprintf(fp,"    Y[ii] = mean;\n");
      fprintf(fp,"    std = 0.0;\n");
      fprintf(fp,"    for (kk = 0; kk < ntimes; kk++) ");
      fprintf(fp," std += (yt[kk] - mean) * (yt[kk] - mean);\n");
      fprintf(fp,"    std = sqrt(std / (ntimes - 1.0));\n");
      fprintf(fp,"    S[ii] = std;\n");
      fprintf(fp,"  }\n");
      fprintf(fp,"  free(u);\n");
      fprintf(fp,"  free(yt);\n");
      fprintf(fp,"  free(coefs);\n");
      fprintf(fp,"  return 0;\n");
      fprintf(fp,"}\n");
      fprintf(fp,"/* ==========================================*/\n");
      fprintf(fp,"/* Put your function definition here.        */\n");
      fprintf(fp,"/* ==========================================*/\n");
      fprintf(fp,"int func(int nInps, double *X, double *Y){\n");
      fprintf(fp,"  Y[0] = X[0] * X[0];\n");
      fprintf(fp,"  Y[1] = X[1] * X[1];\n");
      fprintf(fp,"  return 0;\n");
      fprintf(fp,"}\n");
      fprintf(fp,"/* ==============================================*/\n");
      fprintf(fp,"static double\n");
      fprintf(fp,"CoefEnsemble[%d][100] = \n", numTerms_);
      fprintf(fp,"{\n");
      for (nn = 0; nn < numTerms_; nn++)
      {
         fprintf(fp," { %24.16e", fuzzyC_[nn][0]);
         for (cc = 1; cc < nTimes; cc++)
            fprintf(fp,", %24.16e", fuzzyC_[nn][cc]);
         fprintf(fp," },\n");
      }
      fprintf(fp,"};\n");
      fprintf(fp,"void getCoefs(int kk, double *coefs) {\n");
      fprintf(fp,"  int mm;\n");
      fprintf(fp,"  for (mm = 0; mm < %d; mm++)\n",numTerms_);
      fprintf(fp,"    coefs[mm] = CoefEnsemble[mm][kk];\n");
      fprintf(fp,"}\n");
      fprintf(fp,"/* ==============================================*/\n");
      fclose(fp);
      printf("FILE psuade_rs.info contains the user regression interpolator\n");
   }
   fp = NULL;
   if (psRSCodeGen_ == 1) fp = fopen("psuade_rs.py", "w");
   if (fp != NULL)
   {
      fprintf(fp,"#!/usr/bin/python\n");
      fprintf(fp,"###################################################\n");
      fprintf(fp,"# Response surface interpolator from PSUADE\n");
      fprintf(fp,"#==================================================\n");
      fprintf(fp,"# This file contains information for interpolation\n");
      fprintf(fp,"# using response surface. Follow the steps below:\n");
      fprintf(fp,"#  1. move this file to *.py file (e.g. interpolate.py)\n");
      fprintf(fp,"#  2. modify 'func' to reflect your basis functions.\n");
      fprintf(fp,"#  3. make sure the first line points to your Python\n");
      fprintf(fp,"#  4. prepare your new sample points to be interpolated\n");
      fprintf(fp,"#     in a text file (e.g. infile) with the format below:\n");
      fprintf(fp,"#    <number of sample points M> <number of inputs n>\n");
      fprintf(fp,"#    1 input1 input2 ...inputn\n");
      fprintf(fp,"#    2 input1 input2 ...inputn\n");
      fprintf(fp,"#    ....\n");
      fprintf(fp,"#    M input1 input2 ...inputn\n");
      fprintf(fp,"#  5. run: interpolate.py infile outfile\n");
      fprintf(fp,"#     where <outfile> will have the interpolated values.\n");
      fprintf(fp,"#==================================================\n");
      fprintf(fp,"import sys\n");
      fprintf(fp,"import string\n");
      fprintf(fp,"import math\n\n");
      fprintf(fp,"#==================================================\n");
      fprintf(fp,"# User regressioin interpolation\n");
      fprintf(fp,"#==================================================\n");
      fwriteRSPythonCommon(fp);
      fprintf(fp,"CoefEnsemble = [\n");
      for (nn = 0; nn < numTerms_; nn++)
      {
         fprintf(fp," [ %24.16e", fuzzyC_[nn][0]);
         for (cc = 1; cc < nTimes; cc++)
            fprintf(fp,", %24.16e", fuzzyC_[nn][cc]);
         fprintf(fp,", %24.16e ],\n", regCoeffs_[nn]);
      }
      fprintf(fp,"]\n");
      fprintf(fp,"def getCoefs(kk) :\n");
      fprintf(fp,"  coefs = %d * [0.0]\n",numTerms_);
      fprintf(fp,"  for mm in range(%d) : \n", numTerms_);
      fprintf(fp,"    coefs[mm] = CoefEnsemble[mm][kk];\n");
      fprintf(fp,"  return coefs\n");
      fprintf(fp,"###################################################\n");
      fprintf(fp,"# define your function here \n");
      fprintf(fp,"#==================================================\n");
      fprintf(fp,"def func(X) : \n");
      fprintf(fp,"  nn = len(X)\n");
      fprintf(fp,"  mm = %d\n", numTerms_);
      fprintf(fp,"  U  = mm * [0.0]\n");
      fprintf(fp,"  for ii in range(mm): \n");
      fprintf(fp,"#    fill in your ii-th basis function\n");
      fprintf(fp,"#    U[ii] = evalBasisFcn(ii,X)\n");
      fprintf(fp,"  return U\n");
      fprintf(fp,"###################################################\n");
      fprintf(fp,"# Regression interpolation function  \n");
      fprintf(fp,"# X[0], X[1],   .. X[m-1]   - first point\n");
      fprintf(fp,"# X[m], X[m+1], .. X[2*m-1] - second point\n");
      fprintf(fp,"# ... \n");
      fprintf(fp,"#==================================================\n");
      fprintf(fp,"def interpolate(X): \n");
      fprintf(fp,"  nSamp = int(len(X) / %d)\n", nInputs_);
      fprintf(fp,"  Yt = %d * [0.0]\n", nTimes);
      fprintf(fp,"  Xt = %d * [0.0]\n", nInputs_);
      fprintf(fp,"  Ys = 2 * nSamp * [0.0]\n");
      fprintf(fp,"  for ss in range(nSamp) : \n");
      fprintf(fp,"    for ii in range(%d) : \n", nInputs_);
      fprintf(fp,"      Xt[ii] = X[ss*%d+ii]\n",nInputs_);
      fprintf(fp,"    for kk in range(%d) : \n", nTimes);
      fprintf(fp,"      coefs = getCoefs(kk)\n");
      fprintf(fp,"      U = func(Xt)\n");
      fprintf(fp,"      Y = 0.0\n");
      fprintf(fp,"      for jj in range(%d) : \n", numTerms_);
      fprintf(fp,"        Y += coefs[jj] * U[jj]\n");
      fprintf(fp,"      Yt[kk] = Y * %e + %e;\n", YStd_, YMean_);
      fprintf(fp,"    mean = 0.0;\n");
      fprintf(fp,"    for kk in range(%d) : \n", nTimes);
      fprintf(fp,"      mean += Yt[kk]\n");
      fprintf(fp,"    mean /= %d\n", nTimes);
      fprintf(fp,"    std = 0.0;\n");
      fprintf(fp,"    for kk in range(%d) : \n", nTimes);
      fprintf(fp,"      std += (Yt[kk] - mean) * (Yt[kk] - mean)\n");
      fprintf(fp,"    std = math.sqrt(std / (%d - 1.0))\n",nTimes);
      fprintf(fp,"    Ys[2*ss] = mean\n");
      fprintf(fp,"    Ys[2*ss+1] = std\n");
      fprintf(fp,"  return Ys\n");
      fprintf(fp,"###################################################\n");
      fprintf(fp,"# main program\n");
      fprintf(fp,"#==================================================\n");
      fprintf(fp,"infileName  = sys.argv[1]\n");
      fprintf(fp,"outfileName = sys.argv[2]\n");
      fprintf(fp,"inputs = getInputData(infileName)\n");
      fprintf(fp,"outputs = interpolate(inputs)\n");
      fprintf(fp,"genOutputFile(outfileName, outputs)\n");
      fprintf(fp,"###################################################\n");
      fclose(fp);
      printf("FILE psuade_rs.py contains the user regression interpolator.\n");
   }
 
   delete [] XX;
   delete [] XTX;
   delete [] WW;
   return 0;
}

// *************************************************************************
// load the X matrix
// -------------------------------------------------------------------------
int UserRegression::loadXMatrix(double *X, double **XXOut)
{
   int    M, N, mm, kk;
   double *XX=NULL;
   char   sysCmd[500], lineIn[5001];
   FILE   *fp;

   M = nSamples_;
   N = numTerms_;
   XX = new double[M*N];
   if (psPythonOverride_ == 0)
   {
      if (psPythonInterpreter_ != NULL)
      {
         if (numArgs_ == 2) 
              sprintf(sysCmd,"%s %s ps_input ps_output",
                      psPythonInterpreter_,regFile_);
         else sprintf(sysCmd,"%s %s ps_input ps_output %s",
                      psPythonInterpreter_,regFile_,auxArg_);
      }
      else
      {
         if (numArgs_ == 2) 
              sprintf(sysCmd,"python %s ps_input ps_output",regFile_);
         else sprintf(sysCmd,"python %s ps_input ps_output %s",
                      regFile_,auxArg_);
      }
   }
   else
   {
      if (numArgs_ == 2) 
           sprintf(sysCmd,"%s ps_input ps_output",regFile_);
      else sprintf(sysCmd,"%s ps_input ps_output %s",regFile_,auxArg_);
   }
   fp = fopen("ps_input", "w");
   if(fp == NULL)
   {
      printf("file 'ps_input' expected but not found.\n");
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
   }
   fprintf(fp, "%d %d\n", M, nInputs_);
   for (mm = 0; mm < M; mm++)
   {
      fprintf(fp, "%d", mm+1);
      for (kk = 0; kk < nInputs_; kk++)
         fprintf(fp, " %e", (X[mm*nInputs_+kk]-XNShift_[kk])*XNScale_[kk]);
      fprintf(fp, "\n");
   }
   fclose(fp);
   if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
   system(sysCmd);
   fp = fopen("ps_output", "r");
   if (fp == NULL)
   {
      printf("file 'ps_output' expected but not found.\n");
      printf("fopen returned NULL in file %s line %d, exiting\n", 
             __FILE__, __LINE__);
      exit(1);
   }
   for (mm = 0; mm < M; mm++)
   {
      if (mm == 0)
      {
         fscanf(fp, "%s", lineIn); 
         if (lineIn[0] == '#')
         {
            fgets(lineIn, 5000, fp);
            fscanf(fp, "%d", &kk);
         }
         else sscanf(lineIn, "%d", &kk);
      }
      else fscanf(fp, "%d", &kk);
      if (kk != mm+1)
      {
         printf("ERROR: user output file does not have correct format.\n");
         printf("  Expected index = %d, actual index = %d\n",mm+1,kk);
         fclose(fp);
         exit(1);
      }
      for (kk = 0; kk < N; kk++) fscanf(fp, "%lg", &XX[M*kk+mm]);
      if ((fgets(lineIn, 5000, fp) == NULL) && (mm < M-1))
      {
         printf("ERROR: user output file does not have enough data (%d).\n",
                mm);
         printf("    => %s\n",lineIn);
         fclose(fp);
         exit(1);
      }
   }
   fclose(fp);
   unlink("ps_input");
   unlink("ps_output");
   (*XXOut) = XX;
   return N;
}

// *************************************************************************
// form X^T X 
// -------------------------------------------------------------------------
int UserRegression::computeXTX(int N, double *X, double **XXOut)
{
   int    nn, nn2, mm;
   double *XX, coef;

   XX = new double[nSamples_*N];
   for (nn = 0; nn < N; nn++)
   {
      for (nn2 = 0; nn2 < N; nn2++)
      {
         coef = 0.0;
         for (mm = 0; mm < nSamples_; mm++)
            coef += X[nn*nSamples_+mm] * weights_[mm] * X[nn2*nSamples_+mm];
         XX[nn*N+nn2] = coef;
      }
   }
   (*XXOut) = XX;
   return 0;
}

// *************************************************************************
// compute SS (sum of squares) statistics
// -------------------------------------------------------------------------
int UserRegression::computeSS(int N, double *XX, double *Y,
                              double *B, double &SSresid, double &SStotal)
{
   int    nn, mm;
   double rdata, ymean, SSreg, ddata, SSresidCheck;
                                                                                
   SSresid = SSresidCheck = SStotal = SSreg = ymean = 0.0;
   for (mm = 0; mm < nSamples_; mm++)
      ymean += (sqrt(weights_[mm]) * Y[mm]);
   ymean /= (double) nSamples_;
   for (mm = 0; mm < nSamples_; mm++)
   {
      ddata = 0.0;
      for (nn = 0; nn < N; nn++) ddata += (XX[mm+nn*nSamples_] * B[nn]);
      rdata = Y[mm] - ddata;
      SSresid += Y[mm] * rdata * weights_[mm];
      SSresidCheck += rdata * rdata * weights_[mm];
      SSreg += (ddata - ymean) * (ddata - ymean);
   }
   for (mm = 0; mm < nSamples_; mm++)
      SStotal += weights_[mm] * (Y[mm] - ymean) * (Y[mm] - ymean);
   if (outputLevel_ > 0)
   {
      printf("* UserRegression: SStot  = %24.16e\n", SStotal);
      printf("* UserRegression: SSreg  = %24.16e\n", SSreg);
      printf("* UserRegression: SSres  = %24.16e\n", SSresid);
      printf("* UserRegression: SSres  = %24.16e (true)\n", SSresidCheck);
   }
   SSresid = SSresidCheck;
   if (outputLevel_ > 0 && nSamples_ != N)
   {
      printf("* UserRegression: eps(Y) = %24.16e\n",
             SSresidCheck/(nSamples_-N));
   }
   return 0;
}

// *************************************************************************
// compute coefficient variance ((diagonal of sigma^2 (X' X)^(-1))
// -------------------------------------------------------------------------
int UserRegression::computeCoeffVariance(int N,double *XX,double var,
                                         double *B)
{
   int    ii, jj, lwork, iOne=1, info, errCnt=0;
   double *B2, *work, *XT;
   char   trans[1];
   FILE   *fp;

   (*trans) = 'N';
   B2 = new double[N];
   XT = new double[N*N];
   lwork = 2 * N * N;
   work  = new double[lwork];
   for (ii = 0; ii < N; ii++)
   {
      for (jj = 0; jj < N*N; jj++) XT[jj] = XX[jj];
      for (jj = 0; jj < N; jj++) B2[jj] = 0.0;
      B2[ii] = var;
      dgels_(trans, &N, &N, &iOne, XT, &N, B2, &N, work, &lwork, &info);
      if (info != 0)
         printf("UserRegression WARNING: dgels returns error %d.\n",info);
      if (B2[ii] < 0) errCnt++;
      if (B2[ii] < 0) B[ii] = sqrt(-B2[ii]);
      else            B[ii] = sqrt(B2[ii]);
   }
   if (errCnt > 0)
   {
      printf("* UserRegression WARNING: some of the coefficient\n");
      printf("*            variances are < 0. May spell trouble but\n");
      printf("*            will proceed anyway (%d).\n",errCnt);
   }
   delete [] B2;
   delete [] XT;

   int    *ipiv = new int[N+1];
   double *invA = new double[lwork];
   double ddata, ddata2;
   for (ii = 0; ii < N*N; ii++) invA[ii] = XX[ii];
   dgetrf_(&N, &N, invA, &N, ipiv, &info);
   if (info != 0)
      printf("UserRegression WARNING: dgels returns error %d.\n",info);
   dgetri_(&N, invA, &N, ipiv, work, &lwork, &info);
   covMatrix_.setDim(N,N);
   for (ii = 0; ii < N; ii++)
   {
      for (jj = 0; jj < N; jj++)
      {
         ddata = invA[ii*N+jj] * var;
         covMatrix_.setEntry(ii,jj,ddata);
      }
   }
   for (ii = 0; ii < N; ii++)
   {
      ddata = covMatrix_.getEntry(ii,ii);
      ddata = sqrt(ddata);
      for (jj = 0; jj < N; jj++)
      {
         if (ii != jj)
         {
            ddata2 = covMatrix_.getEntry(ii,jj);
            if (ddata != 0) ddata2 /= ddata;
            covMatrix_.setEntry(ii,jj,ddata2);
         }
      }
   }
   for (jj = 0; jj < N; jj++)
   {
      ddata = covMatrix_.getEntry(jj,jj);
      ddata = sqrt(ddata);
      for (ii = 0; ii < N; ii++)
      {
         if (ii != jj)
         {
            ddata2 = covMatrix_.getEntry(ii,jj);
            if (ddata != 0) ddata2 /= ddata;
            covMatrix_.setEntry(ii,jj,ddata2);
         }
      }
   }
   ddata = 1.0;
   for (ii = 0; ii < N; ii++) covMatrix_.setEntry(ii,ii,ddata);
   for (ii = 0; ii < N; ii++)
   {
      for (jj = 0; jj < ii; jj++)
      {
         ddata  = covMatrix_.getEntry(ii,jj);
         ddata2 = covMatrix_.getEntry(jj,ii);
         ddata  = 0.5 * (ddata + ddata2);
         covMatrix_.setEntry(ii,jj,ddata);
         covMatrix_.setEntry(jj,ii,ddata);
      }
   }
   if (psMasterMode_ == 1)
   {
      fp = fopen("user_regression_correlation_matrix","a");
      fprintf(fp, "C = [\n");
      for (ii = 0; ii < N; ii++)
      {
          for (jj = 0; jj < N; jj++)
             fprintf(fp, "%e ", covMatrix_.getEntry(ii,jj));
          fprintf(fp, "\n");
      }
      fprintf(fp, "];\n");
      fprintf(fp, "XTX = [\n");
      for (ii = 0; ii < N; ii++)
      {
          for (jj = 0; jj < N; jj++)
             fprintf(fp, "%e ", XX[ii*N+jj]);
          fprintf(fp, "\n");
      }
      fprintf(fp, "];\n");
      fprintf(fp, "invA = [\n");
      for (ii = 0; ii < N; ii++)
      {
          for (jj = 0; jj < N; jj++)
             fprintf(fp, "%e ", invA[ii*N+jj]);
          fprintf(fp, "\n");
      }
      fprintf(fp, "];\n");
      fprintf(fp, "variance = %e;\n", var);
      fprintf(fp, "D = diag(variance * invA);\n");
      fprintf(fp, "D = 1.0 ./ D;\n");
      fprintf(fp, "D = sqrt(D);\n");
      fprintf(fp, "C0 = diag(D) * (variance * invA) * diag(D);\n");
      fprintf(fp, "%% C should be equal to C0\n");
      fclose(fp);
   }
   errCnt = 0;
   for (ii = 0; ii < N; ii++)
   {
      for (jj = 0; jj < N; jj++)
      {
         ddata = covMatrix_.getEntry(ii,jj);
         if (ii != jj && (ddata >=1 || ddata <= -1))
         {
            errCnt++;
            covMatrix_.setEntry(ii,jj,0.0);
         }
      }
   }
   char inStr[1001];
   if (errCnt > 0)
   {
      printf("UserRegression WARNING:\n");
      printf("  Correlation matrix has invalid entries (%d out of %d).\n",
             errCnt, N*(N-1));
      printf("  EVALUATION MAY BE INCORRECT.\n");
      printf("  CONTINUE ANYWAY (will set them to zeros)\n");
   }
   delete [] work;
   delete [] ipiv;
   delete [] invA;
   return info;
}

// ************************************************************************
// print statistics
// ------------------------------------------------------------------------
int UserRegression::printRC(int N,double *B,double *Bvar,double *XX,
                            double *Y)
{
   int    ii;
   double coef;

   printDashes(PL_INFO, 0);
   printf("*  Term    coefficient     std. error     t-value\n");
   for (ii = 0; ii < numTerms_; ii++)
   {
      if (PABS(Bvar[ii]) < 1.0e-15) coef = 0.0;
      else                          coef = B[ii] / Bvar[ii]; 
      printf("*   %3d   %12.4e   %12.4e   %12.4e\n",ii+1,B[ii],Bvar[ii],coef);
   }
   printDashes(PL_INFO, 0);
   return 0;
}

// ************************************************************************
// set parameters
// ------------------------------------------------------------------------
double UserRegression::setParams(int targc, char **targv)
{
   struct stat sb;
   FILE   *fp;
   if (targc > 0 && !strcmp(targv[0], "set_user_script"))
   {
      if (targc < 2)
      {
         printf("UserRegression ERROR: setParam - in setting user_script\n");
         exit(1);
      }
      strncpy(regFile_, targv[1], 1000);
      fp = fopen(regFile_, "r");
      if (fp == NULL)
      {
         printf("UserRegression ERROR: user executable %s not found.\n",
                regFile_);
         exit(1);
      }
      fclose(fp);
      if (stat(regFile_, &sb) != 0 || !(sb.st_mode & S_IXUSR))
      {
         printf("UserRegression WARNING : User-provided executable does\n");
         printf("                         not have execute permission.\n");
         exit(1);
      }
   }
   else if (targc == 2 && !strcmp(targv[0], "set_aux_arg"))
   {
      strcpy(auxArg_, targv[1]);
   }
   return 0.0;
}

